<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ° ì”í˜¹ë™í™” ìŠ¬ë¡¯ë¨¸ì‹  ğŸ°</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        
        .symbol-red {
            filter: hue-rotate(0deg) saturate(2) brightness(0.9) contrast(1.2);
            text-shadow: 0 0 8px #ff0000;
        }
        
        .symbol-black {
            filter: grayscale(1) brightness(0.4) contrast(1.5);
            text-shadow: 0 0 8px #000000;
        }
        
        .symbol-gold {
            filter: hue-rotate(45deg) saturate(2) brightness(1.3) contrast(1.1);
            text-shadow: 0 0 8px #ffd700;
        }
        
        .symbol-wild {
            filter: hue-rotate(300deg) saturate(2) brightness(1.2);
            text-shadow: 0 0 8px #ff69b4;
            animation: rainbow 2s linear infinite;
        }
        
        @keyframes rainbow {
            0% { filter: hue-rotate(0deg) saturate(2) brightness(1.2); }
            25% { filter: hue-rotate(90deg) saturate(2) brightness(1.2); }
            50% { filter: hue-rotate(180deg) saturate(2) brightness(1.2); }
            75% { filter: hue-rotate(270deg) saturate(2) brightness(1.2); }
            100% { filter: hue-rotate(360deg) saturate(2) brightness(1.2); }
        }
        
        .animate-ping {
            animation: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;
        }
        
        @keyframes ping {
            75%, 100% {
                transform: scale(2);
                opacity: 0;
            }
        }
        
        .animate-bounce {
            animation: bounce 1s infinite;
        }
        
        @keyframes bounce {
            0%, 100% {
                transform: translateY(-25%);
                animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
            }
            50% {
                transform: none;
                animation-timing-function: cubic-bezier(0, 0, 0.2, 1);
            }
        }
        
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useCallback, useEffect } = React;

        const SYMBOLS = {
            MUSHROOM: { id: 'mushroom', emoji: 'ğŸ„', name: 'ë¶‰ì€ ë²„ì„¯', probability: 0.25, reward: 5, color: 'red' },
            BLACK_FEATHER: { id: 'blackFeather', emoji: 'ğŸª¶', name: 'ê²€ì€ê¹ƒí„¸', probability: 0.20, reward: 8, color: 'black' },
            WITHERED_ROSE: { id: 'witheredRose', emoji: 'ğŸ¥€', name: 'ë¹¨ê°„ ì¥ë¯¸', probability: 0.18, reward: 12, color: 'red' },
            TREASURE_KEY: { id: 'treasureKey', emoji: 'ğŸ—ï¸', name: 'í™©ê¸ˆ ì—´ì‡ ', probability: 0.15, reward: 18, color: 'gold' },
            BLOODY_CROWN: { id: 'bloodyCrown', emoji: 'ğŸ‘‘', name: 'í•ë¹› í™©ê¸ˆ ì™•ê´€', probability: 0.10, reward: 30, color: 'red' },
            CURSED_APPLE: { id: 'cursedApple', emoji: 'ğŸ', name: 'ê²€ì€ ì‚¬ê³¼', probability: 0.07, reward: 50, color: 'black' },
            BLACK_DIAMOND: { id: 'blackDiamond', emoji: 'ğŸ’', name: 'ê²€ì€ ë‹¤ì´ì•„', probability: 0.05, reward: 100, color: 'black' },
            JOKER: { id: 'joker', emoji: 'ğŸƒ', name: 'ì¡°ì»¤ì¹´ë“œ', probability: 0.02, reward: 0, color: 'wild' }
        };

        const HANDS = {
            NO_MATCH: { name: 'ë…¸ë§¤ì¹˜', multiplier: 0, isJackpot: false, description: '-' },
            BLOOD_THREE: { name: 'ë¸”ëŸ¬ë“œ ì“°ë¦¬í˜ì–´', multiplier: 12, isJackpot: true, description: 'ğŸ„ğŸ¥€ğŸ‘‘' },
            DARK_THREE: { name: 'ë‹¤í¬ ì“°ë¦¬í˜ì–´', multiplier: 10, isJackpot: true, description: 'ğŸª¶ğŸğŸ’' },
            GOLD_THREE: { name: 'ê³¨ë“œ ì“°ë¦¬í˜ì–´', multiplier: 15, isJackpot: true, description: 'ğŸ—ï¸ğŸ‘‘ğŸƒ' },
            THREE_OF_A_KIND: { name: 'ì“°ë¦¬ì˜¤ë¸Œì–´ì¹´ì¸ë“œ', multiplier: 8, isJackpot: true, description: 'ê°™ì€ ë¬¸ì–‘ 3ê°œ' },
            RAINBOW: { name: 'ë ˆì¸ë³´ìš°', multiplier: 5, isJackpot: false, description: 'ëª¨ë“  ë¬¸ì–‘ ë‹¤ë¦„' },
            LOW_STRAIGHT: { name: 'ë¡œìš°ìŠ¤íŠ¸ë ˆì´íŠ¸', multiplier: 6, isJackpot: false, description: 'ğŸ„ğŸª¶ğŸ¥€' },
            FULL_HOUSE: { name: 'í’€í•˜ìš°ìŠ¤', multiplier: 15, isJackpot: false, description: '3ê°œ+2ê°œ ì¡°í•©' },
            HIGH_STRAIGHT: { name: 'í•˜ì´ìŠ¤íŠ¸ë ˆì´íŠ¸', multiplier: 25, isJackpot: false, description: 'ğŸ—ï¸ğŸ‘‘ğŸğŸ’' },
            FOUR_OF_A_KIND: { name: 'í¬ì˜¤ë¸Œì–´ì¹´ì¸ë“œ', multiplier: 50, isJackpot: true, description: 'ê°™ì€ ë¬¸ì–‘ 4ê°œ' },
            BLACK_DEAL: { name: 'ë¸”ë™ ë”œ', multiplier: 25, isJackpot: false, description: 'ğŸ’ğŸ’+ (ì¡°ì»¤ë¶ˆê°€)' },
            ROYAL_FLUSH: { name: 'ë¡œì—´í”ŒëŸ¬ì‹œ', multiplier: 200, isJackpot: false, description: 'ğŸğŸ’ğŸƒ' },
            FIVE_OF_A_KIND: { name: 'íŒŒì´ë¸Œì˜¤ë¸Œì–´ì¹´ì¸ë“œ', multiplier: 500, isJackpot: true, description: 'ê°™ì€ ë¬¸ì–‘ 5ê°œ' }
        };

        const SLOT_MULTIPLIERS = { 3: 1.0, 4: 2.5, 5: 5.0 };
        const SPIN_SYMBOLS = Object.keys(SYMBOLS);

        function SlotGame() {
            const [gameState, setGameState] = useState({
                coins: 400,
                activeSlots: 3,
                slots: [null, null, null, null, null],
                spinningSlots: [null, null, null, null, null],
                remainingRespins: 3,
                probabilityBonus: {},
                phase: 'READY',
                selectedSlots: [],
                currentHand: null,
                currentReward: 0,
                message: 'ğŸ° ìŠ¤í•€ì„ ì‹œì‘í•˜ì„¸ìš”! ğŸ°',
                isSpinning: false,
                showCelebration: false
            });

            // ë‹¨ì¼ AudioContext ìƒì„± ë° ê´€ë¦¬
            const audioContextRef = useCallback(() => {
                if (!window.globalAudioContext) {
                    try {
                        window.globalAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch (error) {
                        console.log('AudioContext creation failed');
                        return null;
                    }
                }
                return window.globalAudioContext;
            }, []);

            // ì‚¬ìš´ë“œ í•¨ìˆ˜ë“¤
            const playSpinSound = useCallback(() => {
                const audioContext = audioContextRef();
                if (!audioContext) return;

                try {
                    // AudioContextê°€ suspended ìƒíƒœë¼ë©´ resume
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }

                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    
                    oscillator.type = 'square';
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (error) {
                    console.log('Spin sound failed:', error);
                }
            }, [audioContextRef]);

            const playStopSound = useCallback(() => {
                const audioContext = audioContextRef();
                if (!audioContext) return;

                try {
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }

                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.3);
                    
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    
                    oscillator.type = 'sine';
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                } catch (error) {
                    console.log('Stop sound failed:', error);
                }
            }, [audioContextRef]);

            const playWinSound = useCallback(() => {
                const audioContext = audioContextRef();
                if (!audioContext) return;

                try {
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }

                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.5);
                    
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.type = 'triangle';
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (error) {
                    console.log('Win sound failed:', error);
                }
            }, [audioContextRef]);

            const getMaxSelections = useCallback((activeSlots) => {
                return activeSlots - 1;
            }, []);

            // ìŠ¤í•€ ì• ë‹ˆë©”ì´ì…˜ê³¼ ì‚¬ìš´ë“œ
            useEffect(() => {
                let interval;
                let soundInterval;
                
                if (gameState.isSpinning) {
                    playSpinSound();
                    
                    interval = setInterval(() => {
                        setGameState(prev => {
                            const newSpinning = [...prev.spinningSlots];
                            for (let i = 0; i < prev.activeSlots; i++) {
                                if (!prev.selectedSlots.includes(i)) {
                                    newSpinning[i] = SPIN_SYMBOLS[Math.floor(Math.random() * SPIN_SYMBOLS.length)];
                                }
                            }
                            return { ...prev, spinningSlots: newSpinning };
                        });
                    }, 100);
                    
                    soundInterval = setInterval(() => {
                        playSpinSound();
                    }, 150);
                }
                
                return () => {
                    clearInterval(interval);
                    clearInterval(soundInterval);
                };
            }, [gameState.isSpinning, gameState.selectedSlots, playSpinSound]);

            // ì¶•í•˜ íš¨ê³¼ ìë™ ì œê±°
            useEffect(() => {
                if (gameState.showCelebration) {
                    const timer = setTimeout(() => {
                        setGameState(prev => ({ ...prev, showCelebration: false }));
                    }, 3000);
                    return () => clearTimeout(timer);
                }
            }, [gameState.showCelebration]);

            const isSlotActive = useCallback((index) => {
                return index < gameState.activeSlots;
            }, [gameState.activeSlots]);

            const isJackpotForSlots = useCallback((hand, activeSlots) => {
                const handInfo = HANDS[hand];
                if (!handInfo.isJackpot) return false;
                
                if (activeSlots === 3) {
                    return ['THREE_OF_A_KIND', 'BLOOD_THREE', 'DARK_THREE', 'GOLD_THREE'].includes(hand);
                } else if (activeSlots === 4) {
                    return hand === 'FOUR_OF_A_KIND';
                } else if (activeSlots === 5) {
                    return hand === 'FIVE_OF_A_KIND';
                }
                return false;
            }, []);

            const triggerCelebration = useCallback((reward) => {
                if (reward >= 100) {
                    setGameState(prev => ({ ...prev, showCelebration: true }));
                }
            }, []);

            const weightedRandom = useCallback((weights) => {
                const total = Object.values(weights).reduce((sum, weight) => sum + weight, 0);
                let random = Math.random() * total;
                
                for (const [key, weight] of Object.entries(weights)) {
                    random -= weight;
                    if (random <= 0) return key;
                }
                return Object.keys(weights)[0];
            }, []);

            const generateSymbol = useCallback(() => {
                const weights = {};
                Object.entries(SYMBOLS).forEach(([key, symbol]) => {
                    weights[key] = symbol.probability + (gameState.probabilityBonus[key] || 0);
                });
                return weightedRandom(weights);
            }, [gameState.probabilityBonus, weightedRandom]);

            const evaluateHandNormal = useCallback((symbols) => {
                if (symbols.length === 0) return 'NO_MATCH';

                const counts = {};
                symbols.forEach(symbol => {
                    counts[symbol] = (counts[symbol] || 0) + 1;
                });

                const sortedCounts = Object.entries(counts).sort((a, b) => b[1] - a[1]);
                const maxCount = sortedCounts[0][1];
                const uniqueCount = Object.keys(counts).length;

                if (maxCount >= 5) return 'FIVE_OF_A_KIND';
                if (maxCount >= 4) return 'FOUR_OF_A_KIND';
                if (counts.CURSED_APPLE && counts.BLACK_DIAMOND && counts.JOKER) return 'ROYAL_FLUSH';
                if (counts.BLACK_DIAMOND >= 2) return 'BLACK_DEAL';
                if (symbols.length >= 4 && counts.TREASURE_KEY && counts.BLOODY_CROWN && 
                    counts.CURSED_APPLE && counts.BLACK_DIAMOND) return 'HIGH_STRAIGHT';
                if (symbols.length >= 5 && sortedCounts.length >= 2 && 
                    sortedCounts[0][1] >= 3 && sortedCounts[1][1] >= 2) return 'FULL_HOUSE';
                if (counts.TREASURE_KEY && counts.BLOODY_CROWN && counts.JOKER) return 'GOLD_THREE';
                if (counts.MUSHROOM && counts.WITHERED_ROSE && counts.BLOODY_CROWN) return 'BLOOD_THREE';
                if (counts.BLACK_FEATHER && counts.CURSED_APPLE && counts.BLACK_DIAMOND) return 'DARK_THREE';
                if (maxCount >= 3) return 'THREE_OF_A_KIND';
                if (symbols.length >= 3 && counts.MUSHROOM && counts.BLACK_FEATHER && counts.WITHERED_ROSE) return 'LOW_STRAIGHT';
                if (uniqueCount === symbols.length && symbols.length >= 3) return 'RAINBOW';

                return 'NO_MATCH';
            }, []);

            const evaluateHandWithJokers = useCallback((symbols) => {
                const counts = {};
                symbols.forEach(symbol => {
                    counts[symbol] = (counts[symbol] || 0) + 1;
                });
                
                if (counts.BLACK_DIAMOND >= 2) {
                    return 'BLACK_DEAL';
                }
                
                const nonJokers = symbols.filter(s => s !== 'JOKER');
                const jokerCount = symbols.length - nonJokers.length;
                
                if (jokerCount === 0) {
                    return evaluateHandNormal(symbols);
                }
                
                let bestHand = 'NO_MATCH';
                let bestMultiplier = 0;
                
                const possibleSymbols = Object.keys(SYMBOLS).filter(s => s !== 'JOKER');
                
                function tryAllCombinations(remainingJokers, currentSymbols) {
                    if (remainingJokers === 0) {
                        const hand = evaluateHandNormal(currentSymbols);
                        if (hand !== 'BLACK_DEAL' && HANDS[hand].multiplier > bestMultiplier) {
                            bestHand = hand;
                            bestMultiplier = HANDS[hand].multiplier;
                        }
                        return;
                    }
                    
                    for (const symbol of possibleSymbols) {
                        tryAllCombinations(remainingJokers - 1, [...currentSymbols, symbol]);
                    }
                }
                
                tryAllCombinations(jokerCount, [...nonJokers]);
                return bestHand;
            }, [evaluateHandNormal]);

            const evaluateHand = useCallback((slots, activeSlots) => {
                const activeSymbols = slots.slice(0, activeSlots).filter(s => s !== null);
                return evaluateHandWithJokers(activeSymbols);
            }, [evaluateHandWithJokers]);

            const calculateReward = useCallback((hand, slots, activeSlots) => {
                const handInfo = HANDS[hand];
                if (!handInfo || handInfo.multiplier === 0) return 0;

                const activeSymbols = slots.slice(0, activeSlots).filter(s => s !== null);
                const nonJokerSymbols = activeSymbols.filter(symbolKey => symbolKey !== 'JOKER');
                
                let baseReward;
                if (nonJokerSymbols.length > 0) {
                    baseReward = Math.min(...nonJokerSymbols.map(symbolKey => SYMBOLS[symbolKey].reward));
                } else {
                    baseReward = SYMBOLS.MUSHROOM.reward;
                }

                return Math.floor(baseReward * handInfo.multiplier * SLOT_MULTIPLIERS[activeSlots]);
            }, []);

            const getResponCost = useCallback(() => {
                return gameState.selectedSlots.length * 20;
            }, [gameState.selectedSlots]);

            const executeSpin = useCallback(() => {
                if (gameState.coins < 10) return;
                
                setGameState(prev => ({ 
                    ...prev, 
                    coins: prev.coins - 10,
                    phase: 'SPINNING', 
                    message: 'ğŸ° ìŠ¤í•€ ì¤‘... ğŸ°',
                    isSpinning: true
                }));

                setTimeout(() => {
                    setGameState(prev => {
                        const newSlots = [...prev.slots];
                        
                        for (let i = 0; i < prev.activeSlots; i++) {
                            if (!prev.selectedSlots.includes(i)) {
                                newSlots[i] = generateSymbol();
                            }
                        }

                        const hand = evaluateHand(newSlots, prev.activeSlots);
                        const reward = calculateReward(hand, newSlots, prev.activeSlots);
                        const handInfo = HANDS[hand];
                        const isJackpot = isJackpotForSlots(hand, prev.activeSlots);

                        playStopSound();
                        if (reward > 0) {
                            setTimeout(() => playWinSound(), 300);
                        }

                        if (reward >= 100) {
                            triggerCelebration(reward);
                        }

                        return {
                            ...prev,
                            slots: newSlots,
                            spinningSlots: [...newSlots],
                            currentHand: hand,
                            currentReward: reward,
                            phase: isJackpot ? 'JACKPOT_CHOICE' : 
                                   (prev.remainingRespins > 0 ? 'RESPIN_CHOICE' : 'GAME_OVER'),
                            message: isJackpot ? 
                                `ğŸ‰ ${handInfo.name} ì­íŒŸ! ë³´ìƒ: ${reward}ì½”ì¸ - ì„ íƒí•˜ì„¸ìš”!` : 
                                `${handInfo.name} ${handInfo.description} - ${reward} ì½”ì¸`,
                            isSpinning: false
                        };
                    });
                }, 2000);
            }, [generateSymbol, evaluateHand, calculateReward, isJackpotForSlots, triggerCelebration, playStopSound, playWinSound]);

            const executeRespin = useCallback(() => {
                const respinCost = getResponCost();
                if (gameState.coins < respinCost) return;

                setGameState(prev => {
                    const newBonus = { ...prev.probabilityBonus };
                    prev.selectedSlots.forEach(index => {
                        const symbol = prev.slots[index];
                        if (symbol) {
                            newBonus[symbol] = (newBonus[symbol] || 0) + 0.03;
                        }
                    });

                    const newSpinning = [...prev.spinningSlots];
                    prev.selectedSlots.forEach(index => {
                        newSpinning[index] = prev.slots[index];
                    });

                    return {
                        ...prev,
                        coins: prev.coins - respinCost,
                        phase: 'SPINNING',
                        probabilityBonus: newBonus,
                        remainingRespins: prev.remainingRespins - 1,
                        message: `ğŸ”„ ë¦¬ìŠ¤í•€ ì¤‘... (-${respinCost}ì½”ì¸) ğŸ”„`,
                        isSpinning: true,
                        spinningSlots: newSpinning
                    };
                });

                setTimeout(() => {
                    setGameState(prev => {
                        const newSlots = [...prev.slots];
                        
                        for (let i = 0; i < prev.activeSlots; i++) {
                            if (!prev.selectedSlots.includes(i)) {
                                newSlots[i] = generateSymbol();
                            }
                        }

                        const hand = evaluateHand(newSlots, prev.activeSlots);
                        const reward = calculateReward(hand, newSlots, prev.activeSlots);
                        const handInfo = HANDS[hand];
                        const isJackpot = isJackpotForSlots(hand, prev.activeSlots);

                        playStopSound();
                        if (reward > 0) {
                            setTimeout(() => playWinSound(), 300);
                        }

                        if (reward >= 100) {
                            triggerCelebration(reward);
                        }

                        return {
                            ...prev,
                            slots: newSlots,
                            spinningSlots: [...newSlots],
                            currentHand: hand,
                            currentReward: reward,
                            phase: isJackpot ? 'JACKPOT_CHOICE' : 
                                   (prev.remainingRespins > 0 ? 'RESPIN_CHOICE' : 'GAME_OVER'),
                            message: isJackpot ? 
                                `ğŸ‰ ${handInfo.name} ì­íŒŸ! ë³´ìƒ: ${reward}ì½”ì¸ - ì„ íƒí•˜ì„¸ìš”!` : 
                                `${handInfo.name} ${handInfo.description} - ${reward} ì½”ì¸`,
                            isSpinning: false,
                            selectedSlots: []
                        };
                    });
                }, 2000);
            }, [generateSymbol, evaluateHand, calculateReward, isJackpotForSlots, triggerCelebration, getResponCost, playStopSound, playWinSound]);

            const takeRewardAndEnd = useCallback(() => {
                setGameState(prev => {
                    const newSlots = [...prev.slots];
                    const newSpinningSlots = [...prev.spinningSlots];
                    
                    for (let i = 3; i < 5; i++) {
                        newSlots[i] = null;
                        newSpinningSlots[i] = null;
                    }
                    
                    return {
                        ...prev,
                        coins: prev.coins + prev.currentReward,
                        slots: newSlots,
                        spinningSlots: newSpinningSlots,
                        activeSlots: 3,
                        phase: 'READY',
                        remainingRespins: 3,
                        probabilityBonus: {},
                        selectedSlots: [],
                        currentHand: null,
                        currentReward: 0,
                        message: `ğŸ’° ${prev.currentReward}ì½”ì¸ íšë“! ìƒˆë¡œìš´ í„´ì„ ì‹œì‘í•˜ì„¸ìš”!`
                    };
                });
            }, []);

            const expandSlotsAndContinue = useCallback(() => {
                setGameState(prev => {
                    const newActiveSlots = Math.min(prev.activeSlots + 1, 5);
                    const newSlots = [null, null, null, null, null];
                    const newSpinningSlots = [null, null, null, null, null];
                    
                    return {
                        ...prev,
                        slots: newSlots,
                        spinningSlots: newSpinningSlots,
                        activeSlots: newActiveSlots,
                        phase: 'RESPIN_CHOICE',
                        remainingRespins: 4,
                        selectedSlots: [],
                        currentHand: null,
                        currentReward: 0,
                        message: `ğŸŠ ${newActiveSlots}ìŠ¬ë¡¯ìœ¼ë¡œ í™•ì¥! ëª¨ë“  ìŠ¬ë¡¯ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤! (ë¦¬ìŠ¤í•€ 4íšŒ)`
                    };
                });
            }, []);

            const endTurn = useCallback(() => {
                setGameState(prev => {
                    const newSlots = [...prev.slots];
                    const newSpinningSlots = [...prev.spinningSlots];
                    
                    for (let i = 3; i < 5; i++) {
                        newSlots[i] = null;
                        newSpinningSlots[i] = null;
                    }
                    
                    return {
                        ...prev,
                        coins: prev.coins + prev.currentReward,
                        slots: newSlots,
                        spinningSlots: newSpinningSlots,
                        activeSlots: 3,
                        phase: 'READY',
                        remainingRespins: 3,
                        probabilityBonus: {},
                        selectedSlots: [],
                        currentHand: null,
                        currentReward: 0,
                        message: prev.currentReward > 0 ? 
                            `ğŸ’° ${prev.currentReward}ì½”ì¸ íšë“! ìƒˆë¡œìš´ í„´ì„ ì‹œì‘í•˜ì„¸ìš”!` :
                            'ğŸ° ìƒˆë¡œìš´ í„´ì„ ì‹œì‘í•˜ì„¸ìš”!'
                    };
                });
            }, []);

            const toggleSlotSelection = useCallback((index) => {
                if (gameState.phase !== 'RESPIN_CHOICE' || !isSlotActive(index)) return;
                
                const symbol = gameState.slots[index];
                if (!symbol) return;
                
                setGameState(prev => {
                    const { selectedSlots, activeSlots } = prev;
                    const maxSelections = getMaxSelections(activeSlots);
                    
                    const newSelection = selectedSlots.includes(index) 
                        ? selectedSlots.filter(i => i !== index)
                        : selectedSlots.length < maxSelections ? [...selectedSlots, index] : selectedSlots;
                    
                    return { ...prev, selectedSlots: newSelection };
                });
            }, [gameState.phase, gameState.slots, isSlotActive, getMaxSelections]);

            const getSymbolColorClass = useCallback((symbol) => {
                if (!symbol) return '';
                const symbolInfo = SYMBOLS[symbol];
                switch (symbolInfo.color) {
                    case 'red': return 'symbol-red';
                    case 'black': return 'symbol-black';
                    case 'gold': return 'symbol-gold';
                    case 'wild': return 'symbol-wild';
                    default: return '';
                }
            }, []);

            return (
                <div className="min-h-screen bg-gradient-to-b from-purple-900 via-red-900 to-black text-white p-4 relative overflow-hidden">
                    {gameState.showCelebration && (
                        <div className="fixed inset-0 z-50 pointer-events-none">
                            <div className="absolute inset-0 bg-gradient-to-r from-yellow-400/20 to-red-400/20 animate-pulse"></div>
                            <div className="absolute inset-0 flex items-center justify-center">
                                <div className="text-8xl animate-bounce">ğŸ‰</div>
                            </div>
                            {[...Array(20)].map((_, i) => (
                                <div
                                    key={i}
                                    className="absolute animate-ping"
                                    style={{
                                        left: `${Math.random() * 100}%`,
                                        top: `${Math.random() * 100}%`,
                                        animationDelay: `${Math.random() * 2}s`,
                                        fontSize: `${Math.random() * 20 + 10}px`
                                    }}
                                >
                                    âœ¨
                                </div>
                            ))}
                        </div>
                    )}

                    <div className="max-w-6xl mx-auto relative z-10">
                        <div className="text-center mb-8">
                            <h1 className="text-5xl font-bold mb-4 bg-gradient-to-r from-red-400 to-yellow-400 bg-clip-text text-transparent">
                                ğŸ° ì”í˜¹ë™í™” ìŠ¬ë¡¯ë¨¸ì‹  ğŸ°
                            </h1>
                            <p className="text-lg text-gray-300">ì­íŒŸ ë‹¬ì„± ì‹œ: ì•ˆì „í•œ ë³´ìƒ vs ìœ„í—˜í•œ ë„ì „</p>
                            <p className="text-sm text-red-300 mt-2">ğŸ’° ë¦¬ìŠ¤í•€ ë¹„ìš©: ê³ ì • ìŠ¬ë¡¯ ìˆ˜ Ã— 20ì½”ì¸</p>
                            <p className="text-xs text-orange-300 mt-1">âš ï¸ ë¸”ë™ë”œ: ì¡°ì»¤ë¡œ ëŒ€ì²´ ë¶ˆê°€ëŠ¥í•œ íŠ¹ìˆ˜ ì¡±ë³´</p>
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                            <div className="bg-gradient-to-r from-yellow-600 to-yellow-800 rounded-lg p-4 text-center">
                                <div className="text-2xl font-bold">{gameState.coins}</div>
                                <div className="text-sm">ì½”ì¸</div>
                            </div>
                            <div className="bg-gradient-to-r from-blue-600 to-blue-800 rounded-lg p-4 text-center">
                                <div className="text-2xl font-bold">{gameState.activeSlots}/5</div>
                                <div className="text-sm">í™œì„± ìŠ¬ë¡¯</div>
                            </div>
                            <div className="bg-gradient-to-r from-green-600 to-green-800 rounded-lg p-4 text-center">
                                <div className="text-2xl">{'ğŸ•¯ï¸'.repeat(gameState.remainingRespins)}</div>
                                <div className="text-sm">ë¦¬ìŠ¤í•€ ({gameState.remainingRespins}íšŒ)</div>
                            </div>
                        </div>

                        <div className="text-center mb-6 p-4 bg-gray-800 rounded-lg">
                            <p className="text-xl font-semibold text-yellow-300">{gameState.message}</p>
                            {gameState.currentHand && gameState.currentReward > 0 && (
                                <div className="text-sm text-gray-300 mt-2">
                                    <p>ë°°ìœ¨: {HANDS[gameState.currentHand].multiplier}x Ã— ìŠ¬ë¡¯ë°°ìœ¨: {SLOT_MULTIPLIERS[gameState.activeSlots]}x</p>
                                </div>
                            )}
                            {gameState.phase === 'RESPIN_CHOICE' && gameState.selectedSlots.length > 0 && (
                                <p className="text-sm text-orange-300 mt-2">
                                    ğŸ’¸ ë¦¬ìŠ¤í•€ ë¹„ìš©: {getResponCost()}ì½”ì¸ ({gameState.selectedSlots.length}ê°œ Ã— 20ì½”ì¸)
                                </p>
                            )}
                            {gameState.phase === 'RESPIN_CHOICE' && gameState.selectedSlots.length === 0 && (
                                <p className="text-sm text-blue-300 mt-2">
                                    ğŸ¯ ìµœëŒ€ {getMaxSelections(gameState.activeSlots)}ê°œê¹Œì§€ ê³ ì • ê°€ëŠ¥ (ê³ ì • ì—†ì´ë„ ë¦¬ìŠ¤í•€ ê°€ëŠ¥)
                                </p>
                            )}
                        </div>

                        <div className="bg-gradient-to-b from-gray-800 to-gray-900 rounded-2xl p-8 mb-6 border-4 border-yellow-600">
                            <div className="flex justify-center space-x-6 mb-6">
                                {[0, 1, 2, 3, 4].map((index) => {
                                    const isActive = isSlotActive(index);
                                    const isSelected = gameState.selectedSlots.includes(index);
                                    const symbol = gameState.isSpinning ? gameState.spinningSlots[index] : gameState.slots[index];
                                    
                                    return (
                                        <div
                                            key={index}
                                            className={`
                                                relative w-24 h-24 rounded-xl border-4 flex items-center justify-center text-4xl font-bold
                                                transition-all duration-300
                                                ${!isActive ? 'border-gray-600 bg-gray-700 opacity-50 cursor-not-allowed' : 
                                                  !symbol ? 'border-blue-400 bg-blue-900 cursor-default' :
                                                  isSelected ? 'border-yellow-500 bg-yellow-900 ring-4 ring-yellow-300 cursor-pointer' :
                                                  'border-blue-500 bg-blue-900 hover:bg-blue-800 cursor-pointer'}
                                                ${gameState.isSpinning && !isSelected && isActive ? 'animate-pulse' : ''}
                                            `}
                                            onClick={() => symbol ? toggleSlotSelection(index) : null}
                                        >
                                            {isActive && symbol ? 
                                                <span className={`
                                                    ${gameState.isSpinning && !isSelected ? 'animate-bounce' : ''}
                                                    ${getSymbolColorClass(symbol)}
                                                `}>
                                                    {SYMBOLS[symbol].emoji}
                                                </span> : 
                                                !isActive ? 'ğŸ”’' : 
                                                <span className="text-3xl text-blue-300 animate-pulse">âœ¨</span>
                                            }
                                            {isSelected && (
                                                <div className="absolute -top-2 text-xs animate-ping">â­</div>
                                            )}
                                            {symbol === 'JOKER' && (
                                                <div className="absolute -bottom-2 text-xs animate-bounce">âœ¨</div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>

                            <div className="text-center text-sm text-gray-400 mb-4">
                                <div className="flex justify-center space-x-6">
                                    {[0, 1, 2, 3, 4].map((index) => {
                                        const isActive = isSlotActive(index);
                                        const symbol = gameState.slots[index];
                                        return (
                                            <div key={index} className="w-24 text-center">
                                                {!isActive ? 
                                                    <span className="text-red-400">ğŸ”´ ì ê¹€</span> : 
                                                    symbol ? 
                                                        <span className="text-green-400">ğŸŸ¢ í™œì„±</span> :
                                                        <span className="text-blue-400">â­ ì‹ ê·œ</span>
                                                }
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>

                        <div className="flex flex-wrap justify-center gap-4 mb-8">
                            {gameState.phase === 'READY' && (
                                <button
                                    onClick={executeSpin}
                                    disabled={gameState.coins < 10}
                                    className="px-8 py-4 bg-gradient-to-r from-green-600 to-green-800 hover:from-green-700 hover:to-green-900 rounded-lg font-bold text-xl disabled:opacity-50 transform hover:scale-105 transition-all"
                                >
                                    ğŸ° ìŠ¤í•€ ì‹œì‘ (10 ì½”ì¸)
                                </button>
                            )}

                            {gameState.phase === 'JACKPOT_CHOICE' && (
                                <div className="flex flex-col items-center gap-4 w-full">
                                    <div className="text-center p-4 bg-gradient-to-r from-yellow-900 to-orange-900 rounded-lg border-2 border-yellow-500 animate-pulse">
                                        <h3 className="text-xl font-bold text-yellow-300 mb-2">ğŸ¯ ì­íŒŸ ë‹¬ì„±!</h3>
                                        <p className="text-lg text-white">í˜„ì¬ ë³´ìƒ: <span className="font-bold text-yellow-400">{gameState.currentReward} ì½”ì¸</span></p>
                                        <p className="text-sm text-gray-300 mt-2">ì„ íƒí•˜ì„¸ìš”: ì•ˆì „í•œ ë³´ìƒ vs ìœ„í—˜í•œ ë„ì „</p>
                                    </div>
                                    <div className="flex gap-4">
                                        <button
                                            onClick={takeRewardAndEnd}
                                            className="px-6 py-3 bg-gradient-to-r from-green-600 to-green-800 hover:from-green-700 hover:to-green-900 rounded-lg font-bold transform hover:scale-105 transition-all"
                                        >
                                            ğŸ’° ë³´ìƒ ë°›ê³  í„´ ì¢…ë£Œ
                                        </button>
                                        {gameState.activeSlots < 5 && (
                                            <button
                                                onClick={expandSlotsAndContinue}
                                                className="px-6 py-3 bg-gradient-to-r from-orange-600 to-red-600 hover:from-orange-700 hover:to-red-700 rounded-lg font-bold transform hover:scale-105 transition-all animate-pulse"
                                            >
                                                ğŸŠ ë³´ìƒ í¬ê¸°í•˜ê³  {gameState.activeSlots + 1}ìŠ¬ë¡¯ìœ¼ë¡œ í™•ì¥
                                            </button>
                                        )}
                                    </div>
                                </div>
                            )}

                            {gameState.phase === 'RESPIN_CHOICE' && (
                                <>
                                    <button
                                        onClick={executeRespin}
                                        disabled={gameState.remainingRespins <= 0 || gameState.coins < getResponCost()}
                                        className="px-6 py-3 bg-gradient-to-r from-blue-600 to-blue-800 hover:from-blue-700 hover:to-blue-900 rounded-lg font-bold disabled:opacity-50 transform hover:scale-105 transition-all"
                                    >
                                        ğŸ”„ ë¦¬ìŠ¤í•€ ({getResponCost()}ì½”ì¸)
                                    </button>
                                    <button
                                        onClick={endTurn}
                                        className="px-6 py-3 bg-gradient-to-r from-red-600 to-red-800 hover:from-red-700 hover:to-red-900 rounded-lg font-bold transform hover:scale-105 transition-all"
                                    >
                                        ğŸ í„´ ì¢…ë£Œ
                                    </button>
                                </>
                            )}

                            {gameState.phase === 'GAME_OVER' && (
                                <button
                                    onClick={endTurn}
                                    className="px-8 py-4 bg-gradient-to-r from-purple-600 to-purple-800 hover:from-purple-700 hover:to-purple-900 rounded-lg font-bold text-xl transform hover:scale-105 transition-all"
                                >
                                    â¡ï¸ ë‹¤ìŒ í„´
                                </button>
                            )}
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                            <div className="bg-gradient-to-r from-blue-900 to-indigo-900 rounded-lg p-4 border-2 border-blue-500">
                                <h3 className="text-lg font-bold text-blue-300 mb-3 text-center">ğŸ“Š ë³´ìƒ ê³„ì‚° ê³µì‹</h3>
                                <div className="text-sm text-center">
                                    <p className="text-yellow-300 font-bold">ìµœì¢… ë³´ìƒ = ê¸°ë³¸ë³´ìƒ Ã— ì¡±ë³´ë°°ìœ¨ Ã— ìŠ¬ë¡¯ë°°ìœ¨</p>
                                    <p className="text-xs text-gray-300 mt-2">ë¸”ë™ë”œ: 25ë°° (ì¡°ì»¤ë¶ˆê°€)</p>
                                </div>
                            </div>
                            
                            <div className="bg-gradient-to-r from-orange-900 to-red-900 rounded-lg p-4 border-2 border-orange-500">
                                <h3 className="text-lg font-bold text-orange-300 mb-3 text-center">ğŸ”„ ë¦¬ìŠ¤í•€ ì‹œìŠ¤í…œ</h3>
                                <div className="text-sm text-center">
                                    <p className="text-yellow-300">ê¸°ë³¸: 3íšŒ | í™•ì¥ì‹œ: 4íšŒ</p>
                                    <p className="text-xs text-gray-300 mt-2">ê³ ì • ì—†ì´ë„ ë¦¬ìŠ¤í•€ ê°€ëŠ¥</p>
                                </div>
                            </div>
                        </div>

                        <div className="mb-6 p-4 bg-gradient-to-r from-gray-800 to-gray-900 rounded-lg border-2 border-gray-600">
                            <h3 className="text-lg font-bold text-gray-300 mb-3 text-center">ğŸ’° ë¬¸ì–‘ë³„ ê¸°ë³¸ ë³´ìƒ</h3>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-2 text-sm">
                                {Object.entries(SYMBOLS).map(([key, symbol]) => (
                                    <div key={key} className="flex items-center justify-between bg-gray-700 rounded px-2 py-1">
                                        <span>
                                            <span className={getSymbolColorClass(key)}>
                                                {symbol.emoji}
                                            </span> {symbol.name}
                                        </span>
                                        <span className="font-bold text-yellow-400">{symbol.reward}ì½”ì¸</span>
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div className="bg-gradient-to-br from-red-900 to-red-800 rounded-lg p-6">
                                <h3 className="text-xl font-bold mb-4 text-yellow-400">ğŸ¯ ì­íŒŸ ì¡±ë³´</h3>
                                <div className="space-y-2 text-sm">
                                    <div className="flex justify-between">
                                        <span>ğŸ„ğŸ¥€ğŸ‘‘ ë¸”ëŸ¬ë“œ ì“°ë¦¬í˜ì–´</span>
                                        <span className="font-bold text-red-300">12ë°°</span>
                                    </div>
                                    <div className="flex justify-between">
                                        <span>ğŸª¶ğŸğŸ’ ë‹¤í¬ ì“°ë¦¬í˜ì–´</span>
                                        <span className="font-bold text-gray-300">10ë°°</span>
                                    </div>
                                    <div className="flex justify-between">
                                        <span>ğŸ—ï¸ğŸ‘‘ğŸƒ ê³¨ë“œ ì“°ë¦¬í˜ì–´</span>
                                        <span className="font-bold text-yellow-300">15ë°°</span>
                                    </div>
                                    <div className="flex justify-between">
                                        <span>ğŸ„ğŸ„ğŸ„ ì“°ë¦¬ì˜¤ë¸Œì–´ì¹´ì¸ë“œ</span>
                                        <span className="font-bold text-blue-300">8ë°°</span>
                                    </div>
                                    <div className="flex justify-between">
                                        <span>ğŸ„ğŸ„ğŸ„ğŸ„ í¬ì˜¤ë¸Œì–´ì¹´ì¸ë“œ</span>
                                        <span className="font-bold text-purple-300">50ë°°</span>
                                    </div>
                                    <div className="flex justify-between">
                                        <span>ğŸ„ğŸ„ğŸ„ğŸ„ğŸ„ íŒŒì´ë¸Œì˜¤ë¸Œì–´ì¹´ì¸ë“œ</span>
                                        <span className="font-bold text-pink-300">500ë°°</span>
                                    </div>
                                </div>
                            </div>

                            <div className="bg-gradient-to-br from-purple-900 to-purple-800 rounded-lg p-6">
                                <h3 className="text-xl font-bold mb-4 text-yellow-400">âœ¨ íŠ¹ìˆ˜ ì¡±ë³´</h3>
                                <div className="space-y-2 text-sm">
                                    <div className="flex justify-between">
                                        <span>ğŸğŸ’ğŸƒ ë¡œì—´í”ŒëŸ¬ì‹œ</span>
                                        <span className="font-bold text-yellow-300">200ë°°</span>
                                    </div>
                                    <div className="flex justify-between">
                                        <span>ğŸ’ğŸ’+ ë¸”ë™ ë”œ</span>
                                        <span className="font-bold text-red-400">25ë°°</span>
                                    </div>
                                    <div className="text-xs text-orange-300 mt-1 mb-2">âš ï¸ ì¡°ì»¤ ëŒ€ì²´ ë¶ˆê°€ëŠ¥</div>
                                    <div className="flex justify-between">
                                        <span>ğŸ—ï¸ğŸ‘‘ğŸğŸ’ í•˜ì´ìŠ¤íŠ¸ë ˆì´íŠ¸</span>
                                        <span className="font-bold text-orange-300">25ë°°</span>
                                    </div>
                                    <div className="flex justify-between">
                                        <span>ğŸ„ğŸ„ğŸ„ğŸ¥€ğŸ¥€ í’€í•˜ìš°ìŠ¤</span>
                                        <span className="font-bold text-green-300">15ë°°</span>
                                    </div>
                                    <div className="flex justify-between">
                                        <span>ğŸ„ğŸª¶ğŸ¥€ ë¡œìš°ìŠ¤íŠ¸ë ˆì´íŠ¸</span>
                                        <span className="font-bold text-blue-300">6ë°°</span>
                                    </div>
                                    <div className="flex justify-between">
                                        <span>ğŸ„ğŸª¶ğŸ¥€ğŸ—ï¸ğŸ‘‘ ë ˆì¸ë³´ìš°</span>
                                        <span className="font-bold text-purple-300">5ë°°</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<SlotGame />, document.getElementById('root'));
    </script>
</body>
</html>